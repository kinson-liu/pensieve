title: 进程、线程、协程
author: Kinson
tags:
  - 进程
  - 线程
categories:
  - 操作系统
  - 计算机基础
date: 2021-7-6 20:43:26

---

## 总述

首先来一句概括的总论：进程和线程都是对一个时间段的描述，对CPU工作时间段的描述。

我们的电脑是由 CPU + RAM + 各种资源（比如显卡，光驱，键盘，GPS，等等）构成的，但是电脑的运行，归根结底只是CPU和相关寄存器，以及RAM之间的事情。

### 关于CPU

CPU太快，太快，太快了，寄存器仅仅能够追的上他的脚步，RAM和别的挂在各总线上的设备完全是望其项背。那当多个任务要执行的时候怎么办呢？轮流着来?或者谁优先级高谁来？不管怎么样的策略，一句话就是在CPU看来就是轮流着来。

### 关于程序

当程序执行中得到CPU的时候，相关的资源必须也已经就位，就是显卡啊什么的必须就位，然后CPU开始执行。这里除了CPU，以外的所有就构成了这个程序的执行环境，也就是我们所定义的程序上下文。当这个程序执行完了，或者分配给他的CPU执行时间用完了，那它就要被切换出去，等待下一次CPU的临幸。在被切换出去的最后一步工作就是保存程序上下文，因为这个是下次他被CPU临幸的运行环境，必须保存。

### 程序调度
前面讲过在CPU看来，所有的程序都是一个一个轮流执行的，具体的轮流方法是：先加载程序A的上下文，然后开始执行A，保存程序A的上下文，调入下一个要执行的程序B的程序上下文，然后开始执行B,保存程序B的上下文。如此循环往复……

### 进程和线程
进程和线程，就是在这样的背景之下诞生的。

进程就是包换上下文切换的程序执行时间总和 = CPU加载上下文 + CPU执行 + CPU保存上下文

那么线程是什么呢？进程的颗粒度太大，每次都要有上下的调入，保存，调出。如果我们把进程比喻为一个运行在电脑上的软件，那么一个软件的执行不可能是一条逻辑执行的，必定有多个分支和多个程序段，就好比要实现程序A，实际分成 a，b，c等多个块组合而成。那么这里具体的执行就可能变成：
  1.  程序A得到CPU
  2.  CPU加载上下文
  3.  执行A的a小段
  4.  执行A的b小段
  5.  执行A的c小段
  6.  CPU保存A的上下文

这里a，b，c的执行是共享了A的上下文，CPU在执行的时候没有进行上下文切换的。这里的a，b，c就是线程，也就是说线程是共享了进程的上下文环境，的更为细小的CPU时间段。


## 进程

进程是在系统中能独立运行并作为资源分配的基本单位，它是由一组机器指令、数据和堆栈等组成的，是一个能独立运行的活动实体。

注意：进程一般有三个状态,`就绪状态`、`执行状态`和`等待状态`(或称`阻塞状态`)。进程只能由父进程建立，系统中所有的进程形成一种进程树的层次体系。挂起命令可由进程自己和其他进程发出，但是解除挂起命令只能由其他进程发出。

### 进程控制块（PCB）

PCB不但可以记录进程的属性信息，以便操作系统对进程进行控制和管理，而且PCB标志着进程的存在，操作系统根据系统中是否有该进程的进程控制块PCB而知道该进程存在与否。系统建立进程的同时就建立该进程的PCB，在撤销一个进程时，也就撤销其PCB，故进程的PCB对进程来说是它存在的具体的物理标志和体现。

一般PCB包括以下三类信息：`进程标识信息`，`处理器状态信息`，`进程控制信息`。

由程序段、相关的数据段和PCB三部分构成了进程实体（又称进程印像），一般，我们把进程实体就简称为进程。

### 进程的特征
1.  动态性：  进程的实质是程序的一次执行过程，进程是动态产生，动态消亡的。
2.  并发性：  任何进程都可以同其他进程一起并发执行。
3.  独立性：  进程是一个能独立运行的基本单位，同时也是系统分配资源和调度的独立单位。
4.  异步性：  由于进程间的相互制约，使进程具有执行的间断性，即进程按各自独立的、不可预知的速度向前推进。


## 线程

线程是进程中的一个实体，作为系统调度和分派的基本单位。 Linux 下的线程看作轻量级进程。

### 线程的性质
1.  线程是进程内的一个相对独立的可执行的单元。若把进程称为任务的话，那么线程则是应用中的一个子任务的执行。
2.  由于线程是被调度的基本单元，而进程不是调度单元。所以，每个进程在创建时，至少需要同时为该进程创建一个线程。即进程中至少要有一个或一个以上的线程，否则该进程无法被调度执行。
3.  进程是被分给并拥有资源的基本单元。同一进程内的多个线程共享该进程的资源，但线程并不拥有资源，只是使用他们。
4.  线程是操作系统中基本调度单元，因此线程中应包含有调度所需要的必要信息，且在生命周期中有状态的变化。
5.  由于共享资源【包括数据和文件】，所以线程间需要通信和同步机制，且需要时线程可以创建其他线程，但线程间不存在父子关系。


### 多线程使用的情形

  - 前台和后台工作情况
  - 异步处理工作情况
  - 需要加快执行速度情况
  - 组织复杂工作的情况
  - 同时有多个用户服务请求的情况等。
 
### 线程机制的优点：

多线程运行在同一个进程的相同的地址空间内，和采用多进程相比有以下优点：

1.  创建和撤销线程的开销较之进程要少。创建线程时只需要建立线程控制表相应的表目，或有关队列，而创建进程时，要创建PCB表和初始化，进入有关进程队列，建立它的地址空间和所需资源等。
2.  CPU在线程之间开关时的开销远比进程要少得多。因开关线程都在同一地址空间内，只需要修改线程控制表或队列，不涉及地址空间和其他工作。
3.  线程机制也增加了通讯的有效性。进程间的通讯往往要求内核的参与，以提供通讯机制和保护机制，而线程间的通讯是在同一进程的地址空间内，共享主存和文件，无需内核参与。


### 进程和线程的区别

#### 调度

在传统的操作系统中，CPU调度和分派的基本单位是进程。而在引入线程的操作系统中，则把线程作为CPU调度和分派的基本单位，进程则作为资源拥有的基本单位，从而使传统进程的两个属性分开，线程编程轻装运行，这样可以显著地提高系统的并发性。同一进程中线程的切换不会引起进程切换，从而避免了昂贵的系统调用，但是在由一个进程中的线程切换到另一进程中的线程，依然会引起进程切换。
 
#### 并发性

在引入线程的操作系统中，不仅进程之间可以并发执行，而且在一个进程中的多个线程之间也可以并发执行，因而使操作系统具有更好的并发性，从而更有效地提高系统资源和系统的吞吐量。例如，在一个为引入线程的单CPU操作系统中，若仅设置一个文件服务进程，当它由于某种原因被封锁时，便没有其他的文件服务进程来提供服务。在引入线程的操作系统中，可以在一个文件服务进程设置多个服务线程。当第一个线程等待时，文件服务进程中的第二个线程可以继续运行；当第二个线程封锁时，第三个线程可以继续执行，从而显著地提高了文件服务的质量以及系统的吞吐量。


#### 拥有资源

不论是引入了线程的操作系统，还是传统的操作系统，进程都是拥有系统资源的一个独立单位，他可以拥有自己的资源。一般地说，线程自己不能拥有资源（也有一点必不可少的资源），但它可以访问其隶属进程的资源，亦即一个进程的代码段、数据段以及系统资源（如已打开的文件、I/O设备等），可供同一个进程的其他所有线程共享。


#### 独立性

在同一进程中的不同线程之间的独立性要比不同进程之间的独立性低得多。这是为了防止进程之间彼此干扰和破坏，每个进程都拥有一个独立的地址空间和其它资源，除了共享全局变量外，不允许其它进程的访问。但是同一进程中的不同线程往往是为了提高并发性以及进行相互之间的合作而创建的，它们共享进程的内存地址空间和资源，如每个线程都可以访问它们所属进程地址空间中的所有地址，如一个线程的堆栈可以被其它线程读、写，甚至完全清除。



#### 系统开销

由于在创建或撤销进程时，系统都要为之分配或回收资源，如内存空间、I/O设备等。因此，操作系统为此所付出的开销将显著地大于在创建或撤消线程时的开销。类似的，在进程切换时，涉及到整个当前进程CPU环境的保存环境的设置以及新被调度运行的CPU环境的设置，而线程切换只需保存和设置少量的寄存器的内容，并不涉及存储器管理方面的操作，可见，进程切换的开销也远大于线程切换的开销。此外，由于同一进程中的多个线程具有相同的地址空间，致使他们之间的同步和通信的实现也变得比较容易。在有的系统中，现成的切换、同步、和通信都无需操作系统内核的干预。



#### 支持多处理机系统

在多处理机系统中，对于传统的进程，即单线程进程，不管有多少处理机，该进程只能运行在一个处理机上。但对于多线程进程，就可以将一个进程中的多个线程分配到多个处理机上，使它们并行执行，这无疑将加速进程的完成。因此，现代处理机OS都无一例外地引入了多线程。